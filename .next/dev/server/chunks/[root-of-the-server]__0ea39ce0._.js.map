{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 58, "column": 0}, "map": {"version":3,"sources":["file:///C:/Rakib/Learning/shortner-v4/app/api/links/route.ts"],"sourcesContent":["import { NextRequest, NextResponse } from 'next/server';\r\nimport path from 'path';\r\nimport fs from 'fs/promises';\r\n\r\n/**\r\n * GET handler to retrieve all stored link mappings. The data is stored\r\n * as an object keyed by id in the JSON file. This endpoint returns\r\n * that object directly. If the file is missing or invalid, it\r\n * returns an empty object.\r\n */\r\n// The GET handler now accepts a NextRequest so that we can read\r\n// cookies sent by the client. We return only the entries for the\r\n// authenticated user. If no authentication cookie is present we\r\n// respond with a 401 status to indicate that login is required.\r\nexport async function GET(req: NextRequest) {\r\n  // Determine which user is making the request. We expect the\r\n  // frontend to set a cookie named `username` after a successful\r\n  // login. Without this cookie we cannot scope the returned data\r\n  // and therefore reject the request.\r\n  const usernameCookie = req.cookies.get('username');\r\n  const username = usernameCookie?.value;\r\n  if (!username) {\r\n    return NextResponse.json({ error: 'Unauthorized' }, { status: 401 });\r\n  }\r\n  const dataFile = path.join(process.cwd(), 'data', 'links.json');\r\n  try {\r\n    const json = await fs.readFile(dataFile, 'utf8');\r\n    const linksData = JSON.parse(json) as Record<string, any>;\r\n    // If the file is organised by id at the root (flat structure),\r\n    // return all entries so that legacy data remains visible. A\r\n    // flat structure is detected by checking if any value has an id\r\n    // property. Otherwise we assume the top-level keys are user\r\n    // names.\r\n    const hasFlatEntries = Object.values(linksData).some((v: any) =>\r\n      v && typeof v === 'object' && 'id' in v\r\n    );\r\n    if (hasFlatEntries) {\r\n      return NextResponse.json(linksData);\r\n    }\r\n    const userLinks = linksData[username] ?? {};\r\n    return NextResponse.json(userLinks);\r\n  } catch {\r\n    return NextResponse.json({});\r\n  }\r\n}"],"names":[],"mappings":";;;;AAAA;AACA;AACA;;;;AAYO,eAAe,IAAI,GAAgB;IACxC,4DAA4D;IAC5D,+DAA+D;IAC/D,+DAA+D;IAC/D,oCAAoC;IACpC,MAAM,iBAAiB,IAAI,OAAO,CAAC,GAAG,CAAC;IACvC,MAAM,WAAW,gBAAgB;IACjC,IAAI,CAAC,UAAU;QACb,OAAO,gJAAY,CAAC,IAAI,CAAC;YAAE,OAAO;QAAe,GAAG;YAAE,QAAQ;QAAI;IACpE;IACA,MAAM,WAAW,4GAAI,CAAC,IAAI,CAAC,QAAQ,GAAG,IAAI,QAAQ;IAClD,IAAI;QACF,MAAM,OAAO,MAAM,gIAAE,CAAC,QAAQ,CAAC,UAAU;QACzC,MAAM,YAAY,KAAK,KAAK,CAAC;QAC7B,+DAA+D;QAC/D,4DAA4D;QAC5D,gEAAgE;QAChE,4DAA4D;QAC5D,SAAS;QACT,MAAM,iBAAiB,OAAO,MAAM,CAAC,WAAW,IAAI,CAAC,CAAC,IACpD,KAAK,OAAO,MAAM,YAAY,QAAQ;QAExC,IAAI,gBAAgB;YAClB,OAAO,gJAAY,CAAC,IAAI,CAAC;QAC3B;QACA,MAAM,YAAY,SAAS,CAAC,SAAS,IAAI,CAAC;QAC1C,OAAO,gJAAY,CAAC,IAAI,CAAC;IAC3B,EAAE,OAAM;QACN,OAAO,gJAAY,CAAC,IAAI,CAAC,CAAC;IAC5B;AACF"}}]
}